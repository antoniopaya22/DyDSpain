/**
 * AbilitiesTab - Pestaña de habilidades de clase del personaje.
 *
 * Para lanzadores de conjuros: muestra espacios de conjuro, trucos, hechizos
 * conocidos/preparados, libro de hechizos (mago), magia de pacto (brujo), y
 * puntos de hechicería.
 *
 * Para no-lanzadores: muestra habilidades de clase específicas como Furia
 * (bárbaro), Puntos de Ki (monje), Ataque Furtivo (pícaro), etc.
 *
 * This is the orchestrator shell — all section UI lives in ./abilities/*.
 */

import { useState } from "react";
import {
  View,
  ScrollView,
  Text,
} from "react-native";
import { useCharacterStore } from "@/stores/characterStore";
import { ConfirmDialog, Toast } from "@/components/ui";
import { useTheme, useDialog, useToast } from "@/hooks";
import {
  SPELLCASTING_ABILITY,
  CLASS_CASTER_TYPE,
  CLASS_SPELL_PREPARATION,
} from "@/types/spell";
import type { ClassId } from "@/types/character";
import { getClassData } from "@/data/srd/classes";
import { getSpellById } from "@/data/srd/spells";
import { CLASS_ABILITY_THEME } from "@/constants/abilities";

// Section components
import ClassResourceSlots from "./abilities/ClassResourceSlots";
import ClassAbilitiesSection from "./abilities/ClassAbilitiesSection";
import SpellcastingSection from "./abilities/SpellcastingSection";
import CantripsSection from "./abilities/CantripsSection";
import CharacterTraitsSection from "./abilities/CharacterTraitsSection";

// ─── Component ───────────────────────────────────────────────────────

export default function AbilitiesTab() {
  const { colors } = useTheme();
  const { dialogProps, showConfirm } = useDialog();
  const { toastProps, showInfo: showToast } = useToast();
  const {
    character,
    magicState,
    classResources,
    useSpellSlot,
    restoreSpellSlot,
    restoreAllSpellSlots,
    usePactSlot,
    restoreAllPactSlots,
    setConcentration,
    clearConcentration,
    useTraitCharge,
    restoreTraitCharges,
    useClassResource,
    useClassResourceAmount,
    restoreClassResource,
    restoreAllClassResources,
  } = useCharacterStore();

  const [expandedAbility, setExpandedAbility] = useState<string | null>(null);

  if (!character) {
    return (
      <View className="flex-1 items-center justify-center p-8">
        <Text className="text-dark-500 dark:text-dark-300 text-base">
          No se ha cargado ningún personaje
        </Text>
      </View>
    );
  }

  // ── Derived values ──

  const casterType = CLASS_CASTER_TYPE[character.clase];
  const spellcastingAbility =
    SPELLCASTING_ABILITY[character.clase as keyof typeof SPELLCASTING_ABILITY];
  const preparationType = CLASS_SPELL_PREPARATION[character.clase];
  const classData = getClassData(character.clase);
  const classTheme = CLASS_ABILITY_THEME[character.clase];

  const isNonCaster = casterType === "none";

  const abilityMod = spellcastingAbility
    ? character.abilityScores[spellcastingAbility].modifier
    : 0;
  const profBonus = character.proficiencyBonus;
  const spellSaveDC = 8 + profBonus + abilityMod;
  const spellAttackBonus = profBonus + abilityMod;

  // ── Spell data (for casters) ──

  const allSpellIds = magicState
    ? [
        ...new Set([
          ...magicState.knownSpellIds,
          ...magicState.preparedSpellIds,
          ...magicState.spellbookIds,
        ]),
      ]
    : [
        ...new Set([
          ...character.knownSpellIds,
          ...character.preparedSpellIds,
          ...character.spellbookIds,
        ]),
      ];

  const cantrips = allSpellIds.filter((id) => {
    const spell = getSpellById(id);
    return spell
      ? spell.nivel === 0
      : id.startsWith("truco_") || id.includes("truco");
  });
  const levelSpells = allSpellIds.filter((id) => {
    const spell = getSpellById(id);
    return spell
      ? spell.nivel > 0
      : !id.startsWith("truco_") && !id.includes("truco");
  });

  const spellsByLevel: Record<number, string[]> = {};
  for (const id of levelSpells) {
    const spell = getSpellById(id);
    const lvl = spell?.nivel ?? 1;
    if (!spellsByLevel[lvl]) spellsByLevel[lvl] = [];
    spellsByLevel[lvl].push(id);
  }
  const sortedSpellLevels = Object.keys(spellsByLevel)
    .map(Number)
    .sort((a, b) => a - b);

  const formatSpellName = (id: string): string => {
    const spell = getSpellById(id);
    if (spell) return spell.nombre;
    return id
      .replace(/^truco_/, "")
      .replace(/_/g, " ")
      .replace(/\b\w/g, (c) => c.toUpperCase());
  };

  const getSpellLevel = (id: string): number =>
    getSpellById(id)?.nivel ?? 1;

  const canCastSpell = (id: string): boolean => {
    if (preparationType === "known" || preparationType === "none") return true;
    return isPrepared(id);
  };

  const isPrepared = (id: string): boolean => {
    if (magicState) return magicState.preparedSpellIds.includes(id);
    return character.preparedSpellIds.includes(id);
  };

  const isInSpellbook = (id: string): boolean => {
    if (magicState) return magicState.spellbookIds.includes(id);
    return character.spellbookIds.includes(id);
  };

  // ── Spell Slot Actions ──

  const handleUseSlot = async (level: number) => {
    const success = await useSpellSlot(level);
    if (success) showToast(`Espacio de nivel ${level} usado`);
    else showToast(`No quedan espacios de nivel ${level}`);
  };

  const handleRestoreSlot = async (level: number) => {
    await restoreSpellSlot(level);
    showToast(`Espacio de nivel ${level} restaurado`);
  };

  const handleRestoreAllSlots = () => {
    showConfirm(
      "Restaurar Espacios",
      "¿Restaurar todos los espacios de conjuro?",
      async () => {
        await restoreAllSpellSlots();
        if (character.clase === "brujo") await restoreAllPactSlots();
        showToast("Todos los espacios restaurados");
      },
      { confirmText: "Restaurar", cancelText: "Cancelar", type: "info" },
    );
  };

  const handleUsePactSlot = async () => {
    const success = await usePactSlot();
    if (success) showToast("Espacio de pacto usado");
    else showToast("No quedan espacios de pacto");
  };

  // ── Trait Actions ──

  const handleUseTraitCharge = async (traitId: string, traitName: string) => {
    await useTraitCharge(traitId);
    showToast(`${traitName}: uso consumido`);
  };

  const handleRestoreTraitCharges = async (
    traitId: string,
    traitName: string,
  ) => {
    await restoreTraitCharges(traitId);
    showToast(`${traitName}: usos restaurados`);
  };

  // ── Class Resource Actions ──

  const handleUseClassResource = async (
    resourceId: string,
    nombre: string,
  ) => {
    const success = await useClassResource(resourceId);
    if (success) showToast(`${nombre}: uso consumido`);
    else showToast(`${nombre}: no quedan usos`);
  };

  const handleUseClassResourceAmount = async (
    resourceId: string,
    amount: number,
    abilityName: string,
  ) => {
    const res = classResources?.resources[resourceId];
    if (!res || res.current < amount) {
      const resName = res?.nombre ?? resourceId;
      showToast(`${abilityName}: no tienes suficientes ${resName}`);
      return;
    }
    const ok = await useClassResourceAmount(resourceId, amount);
    if (ok) showToast(`${abilityName}: -${amount} ${res.nombre}`);
  };

  const handleRestoreClassResource = async (
    resourceId: string,
    nombre: string,
  ) => {
    await restoreClassResource(resourceId);
    showToast(`${nombre}: usos restaurados`);
  };

  const handleRestoreAllClassResources = () => {
    showConfirm(
      "Restaurar Recursos",
      "¿Restaurar todos los recursos de clase?",
      async () => {
        await restoreAllClassResources();
        showToast("Recursos restaurados");
      },
      { confirmText: "Restaurar", cancelText: "Cancelar", type: "info" },
    );
  };

  // ══════════════════════════════════════════════════════════════════
  // RENDER
  // ══════════════════════════════════════════════════════════════════

  if (isNonCaster) {
    return (
      <View style={{ flex: 1 }}>
        <ScrollView
          className="flex-1"
          contentContainerStyle={{ paddingHorizontal: 16, paddingBottom: 40 }}
          showsVerticalScrollIndicator={false}
        >
          <ClassAbilitiesSection
            character={character}
            classData={classData}
            classTheme={classTheme}
            classResources={classResources}
            profBonus={profBonus}
            expandedAbility={expandedAbility}
            setExpandedAbility={setExpandedAbility}
            onRestoreAllResources={handleRestoreAllClassResources}
            onUseResource={handleUseClassResource}
            onRestoreResource={handleRestoreClassResource}
            onUseResourceAmount={handleUseClassResourceAmount}
          />
          <ClassResourceSlots
            classResources={classResources}
            classTheme={classTheme}
            onRestoreAll={handleRestoreAllClassResources}
            onUse={handleUseClassResource}
            onRestore={handleRestoreClassResource}
          />
          <CharacterTraitsSection
            traits={character.traits}
            onUseCharge={handleUseTraitCharge}
            onRestoreCharges={handleRestoreTraitCharges}
          />
        </ScrollView>
        <ConfirmDialog {...dialogProps} />
        <Toast {...toastProps} />
      </View>
    );
  }

  // Caster
  return (
    <View style={{ flex: 1 }}>
      <ScrollView
        className="flex-1"
        contentContainerStyle={{ paddingHorizontal: 16, paddingBottom: 40 }}
        showsVerticalScrollIndicator={false}
      >
        <CantripsSection
          cantrips={cantrips}
          formatSpellName={formatSpellName}
        />
        <SpellcastingSection
          character={character}
          magicState={magicState}
          spellcastingAbility={spellcastingAbility}
          preparationType={preparationType}
          abilityMod={abilityMod}
          profBonus={profBonus}
          spellSaveDC={spellSaveDC}
          spellAttackBonus={spellAttackBonus}
          levelSpells={levelSpells}
          spellsByLevel={spellsByLevel}
          sortedSpellLevels={sortedSpellLevels}
          formatSpellName={formatSpellName}
          getSpellLevel={getSpellLevel}
          canCastSpell={canCastSpell}
          isPrepared={isPrepared}
          isInSpellbook={isInSpellbook}
          onUseSlot={handleUseSlot}
          onRestoreSlot={handleRestoreSlot}
          onRestoreAllSlots={handleRestoreAllSlots}
          onUsePactSlot={handleUsePactSlot}
          onRestoreAllPactSlots={restoreAllPactSlots}
          onClearConcentration={clearConcentration}
          onShowToast={showToast}
          showConfirm={showConfirm}
        />
        <CharacterTraitsSection
          traits={character.traits}
          onUseCharge={handleUseTraitCharge}
          onRestoreCharges={handleRestoreTraitCharges}
        />
      </ScrollView>
      <ConfirmDialog {...dialogProps} />
      <Toast {...toastProps} />
    </View>
  );
}
